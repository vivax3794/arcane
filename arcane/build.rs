use std::path::PathBuf;
use std::{env, fs};

fn main() {
    // Location of Cargo.toml for the current package
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let cargo_toml_path = PathBuf::from(&manifest_dir).join("Cargo.toml");

    // Tell cargo to rebuild if Cargo.toml changes
    println!("cargo:rerun-if-changed={}", cargo_toml_path.display());

    // Read and parse Cargo.toml
    let cargo_toml = fs::read_to_string(&cargo_toml_path).expect("Failed to read Cargo.toml");
    let parsed_toml: toml::Value = toml::from_str(&cargo_toml).expect("Invalid Cargo.toml");

    // Extract dependencies
    let mut dependencies = Vec::new();
    if let Some(deps) = parsed_toml.get("dependencies") {
        if let Some(deps_table) = deps.as_table() {
            for (dep_name, _) in deps_table {
                if dep_name.starts_with("arcane") {
                    dependencies.push(dep_name.clone());
                }
            }
        }
    }

    // Generate a file that references all dependencies
    // We'll place it in OUT_DIR so it doesn't dirty the src/ tree.
    let out_dir = env::var("OUT_DIR").unwrap();
    let target_file = PathBuf::from(&out_dir).join("auto_load.rs");

    let mut output = String::new();
    output.push_str("// This file is auto-generated by build.rs\n");
    for dep in dependencies {
        // Each line ensures the dependency is "used"
        output.push_str(&format!("extern crate {};\n", dep.replace('-', "_")));
    }

    fs::write(&target_file, output).expect("Failed to write auto_load.rs");
}
